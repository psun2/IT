//- 피보나치 수열을 재귀 함수로 구현할 수 있습니다.

//피보나치 수열 이란?
//		저는 수학과 영어를 제일 싫어 합니다. 그래서 약수, 공약수, 최대공약수, 최소공약수, 팩토리얼 등등.. 아무것도 몰라서
//		꼭 이렇게 저만의 공부법처럼 하나하나 알아갈때마다 조사해서 적어놓는 습관을 가지고 있습니다.
//		피보나치 수열을 구글, 네이버 등 포털사이트의 백과사전을 참고해보면.....음.... 모르겠습니다.
//		다만, 이미지등 여러 사람들의 글을 보고 피보나치 수열의 생김새를 보고 알 수 있엇습니다.
//		
//피보나치 수열 의 구조
//1 + 1 + (1 + 1 = 2) + (1 + 2 = 3) + (2 + 3 = 5) + (3 + 5 = 8) + (5 + 8 = 13).......
//a + b + (a + b = c) + (b + c = d) + (c + d = e)....... 
//즉, a 와 b 를 더해 새로운 c 를 만들고, b 와 c 를 더해 새로운 d 를 만들고 한칸씩 밀려 나면서 새롭게 만들어 진것과 더해 줍니다.
//처음보면 이해도 안가고 어렵고 복잡한 구조 입니다. 
//결국은 아래와 같은 수열이 됩니다.
//1 + 1 + 2 + 3 + 5 + 8 + 13 ....
//1, 1, 2, 3, 5, 8, 13......

//재귀란 무엇인가 ?
//		재귀 함수를 배우면서, 이해가 안가 재귀라는 뜻 부터 찾아보았습니다.
//		재귀의 사전적의미 : 본디의 곳으로 다시 올아오는 것
//		외국인 프로그래머들은 이런 단어가 있는 지 모르겠지만,
//		아무래도 한국인의 이해를 돕기위해 한글로 번역하는 과정에서 재귀란 단어가 생기지 않앗나
//		뇌피셜 입니다.
//		즉 본인이 본인을 호출한다(?) 라고 정의 하고싶습니다. 
//		함수를 작성하고 로직끝에 그함수를 통해 자신이 얻고자 하는 값의 로직을 추가해 
//		반복적인 작업의 로직을 조금 더 간단하게 할 수 있는 장점 이 있습니다.

public class 피보나치수열_재귀함수 {

	public static int fibonacci(int number) {
		int one = 1;
		int two = 1;
		if(number == 1) {
			return one;
		} else if(number == 2) {
			return two;
		} else {
			return fibonacci(number -1) + fibonacci(number -1);
//			피보나치 수열의 특징은 x번째 index 의 값은 x-1 번째와 x -2번째의 값을 더한 값이 x 번째 index입니다.
		}
	}
	
	public static void main(String[] args) {
		
		System.out.println("피보나치 수열의 10번째 원소는 " + fibonacci(10) + " 입니다.");
		System.out.println("피보나치 수열의 100번째 원소는 " + fibonacci(100) + " 입니다.");
		
//		재귀함수의 단점 : 피보나치의 100번째 원소를 보고자 할때, x 의 x-1번째 와 x-2번째를 더해주는데,
//		x-1 째를 찾고자할때, x-1번째의 x-1번째 와 x-2번째를 또 찾고, 계속 엄청난 알고리즘이 반복됩니다.
//		이 과정에서 컴퓨터의 연산이 아무리 빠르다하여, 끝 까지 계산을 하지 못하는 현상이 일어납니다.
//		재귀 함수는 간단한 알고리즘을 작성할때, 코드를 좀더 보기 편한게 하는 장점을 가지고 있지만,
//		알고리즘의 양이 늘어나면, 계산 하지 못하는 오류를 범하게 됩니다.

	}

}
